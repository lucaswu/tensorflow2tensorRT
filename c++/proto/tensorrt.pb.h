// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorrt.proto

#ifndef PROTOBUF_INCLUDED_tensorrt_2eproto
#define PROTOBUF_INCLUDED_tensorrt_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorrt_2eproto 

namespace protobuf_tensorrt_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorrt_2eproto
namespace tensorrt {
class Argument;
class ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class ConstTensor;
class ConstTensorDefaultTypeInternal;
extern ConstTensorDefaultTypeInternal _ConstTensor_default_instance_;
class InOutTensorInfo;
class InOutTensorInfoDefaultTypeInternal;
extern InOutTensorInfoDefaultTypeInternal _InOutTensorInfo_default_instance_;
class NetDef;
class NetDefDefaultTypeInternal;
extern NetDefDefaultTypeInternal _NetDef_default_instance_;
class OperatorDef;
class OperatorDefDefaultTypeInternal;
extern OperatorDefDefaultTypeInternal _OperatorDef_default_instance_;
class OutputShape;
class OutputShapeDefaultTypeInternal;
extern OutputShapeDefaultTypeInternal _OutputShape_default_instance_;
class QuantizeActivationInfo;
class QuantizeActivationInfoDefaultTypeInternal;
extern QuantizeActivationInfoDefaultTypeInternal _QuantizeActivationInfo_default_instance_;
}  // namespace tensorrt
namespace google {
namespace protobuf {
template<> ::tensorrt::Argument* Arena::CreateMaybeMessage<::tensorrt::Argument>(Arena*);
template<> ::tensorrt::ConstTensor* Arena::CreateMaybeMessage<::tensorrt::ConstTensor>(Arena*);
template<> ::tensorrt::InOutTensorInfo* Arena::CreateMaybeMessage<::tensorrt::InOutTensorInfo>(Arena*);
template<> ::tensorrt::NetDef* Arena::CreateMaybeMessage<::tensorrt::NetDef>(Arena*);
template<> ::tensorrt::OperatorDef* Arena::CreateMaybeMessage<::tensorrt::OperatorDef>(Arena*);
template<> ::tensorrt::OutputShape* Arena::CreateMaybeMessage<::tensorrt::OutputShape>(Arena*);
template<> ::tensorrt::QuantizeActivationInfo* Arena::CreateMaybeMessage<::tensorrt::QuantizeActivationInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorrt {

enum TensorType {
  DT_INVALID = 0,
  DT_FLOAT = 1,
  DT_UINT8 = 2,
  DT_HALF = 3,
  DT_INT32 = 4
};
bool TensorType_IsValid(int value);
const TensorType TensorType_MIN = DT_INVALID;
const TensorType TensorType_MAX = DT_INT32;
const int TensorType_ARRAYSIZE = TensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TensorType_descriptor();
inline const ::std::string& TensorType_Name(TensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TensorType_descriptor(), value);
}
inline bool TensorType_Parse(
    const ::std::string& name, TensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TensorType>(
    TensorType_descriptor(), name, value);
}
// ===================================================================

class ConstTensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorrt.ConstTensor) */ {
 public:
  ConstTensor();
  virtual ~ConstTensor();

  ConstTensor(const ConstTensor& from);

  inline ConstTensor& operator=(const ConstTensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstTensor(ConstTensor&& from) noexcept
    : ConstTensor() {
    *this = ::std::move(from);
  }

  inline ConstTensor& operator=(ConstTensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstTensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstTensor* internal_default_instance() {
    return reinterpret_cast<const ConstTensor*>(
               &_ConstTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ConstTensor* other);
  friend void swap(ConstTensor& a, ConstTensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstTensor* New() const final {
    return CreateMaybeMessage<ConstTensor>(NULL);
  }

  ConstTensor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConstTensor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConstTensor& from);
  void MergeFrom(const ConstTensor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstTensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // repeated float float_data = 3 [packed = true];
  int float_data_size() const;
  void clear_float_data();
  static const int kFloatDataFieldNumber = 3;
  float float_data(int index) const;
  void set_float_data(int index, float value);
  void add_float_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      float_data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_float_data();

  // repeated int32 int32_data = 4 [packed = true];
  int int32_data_size() const;
  void clear_int32_data();
  static const int kInt32DataFieldNumber = 4;
  ::google::protobuf::int32 int32_data(int index) const;
  void set_int32_data(int index, ::google::protobuf::int32 value);
  void add_int32_data(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      int32_data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_int32_data();

  // optional string name = 5;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int64 offset = 6;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 6;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // optional int64 data_size = 7;
  bool has_data_size() const;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 7;
  ::google::protobuf::int64 data_size() const;
  void set_data_size(::google::protobuf::int64 value);

  // optional float scale = 8;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 8;
  float scale() const;
  void set_scale(float value);

  // optional int32 zero_point = 9;
  bool has_zero_point() const;
  void clear_zero_point();
  static const int kZeroPointFieldNumber = 9;
  ::google::protobuf::int32 zero_point() const;
  void set_zero_point(::google::protobuf::int32 value);

  // optional bool quantized = 10 [default = false];
  bool has_quantized() const;
  void clear_quantized();
  static const int kQuantizedFieldNumber = 10;
  bool quantized() const;
  void set_quantized(bool value);

  // optional .tensorrt.TensorType data_type = 2 [default = DT_FLOAT];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  ::tensorrt::TensorType data_type() const;
  void set_data_type(::tensorrt::TensorType value);

  // @@protoc_insertion_point(class_scope:tensorrt.ConstTensor)
 private:
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_name();
  void clear_has_name();
  void set_has_offset();
  void clear_has_offset();
  void set_has_data_size();
  void clear_has_data_size();
  void set_has_scale();
  void clear_has_scale();
  void set_has_zero_point();
  void clear_has_zero_point();
  void set_has_quantized();
  void clear_has_quantized();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  ::google::protobuf::RepeatedField< float > float_data_;
  mutable int _float_data_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > int32_data_;
  mutable int _int32_data_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 data_size_;
  float scale_;
  ::google::protobuf::int32 zero_point_;
  bool quantized_;
  int data_type_;
  friend struct ::protobuf_tensorrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorrt.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(Argument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Argument* other);
  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Argument* New() const final {
    return CreateMaybeMessage<Argument>(NULL);
  }

  Argument* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float floats = 5;
  int floats_size() const;
  void clear_floats();
  static const int kFloatsFieldNumber = 5;
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::google::protobuf::RepeatedField< float >&
      floats() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_floats();

  // repeated int64 ints = 6;
  int ints_size() const;
  void clear_ints();
  static const int kIntsFieldNumber = 6;
  ::google::protobuf::int64 ints(int index) const;
  void set_ints(int index, ::google::protobuf::int64 value);
  void add_ints(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      ints() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_ints();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes s = 4;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 4;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  #if LANG_CXX11
  void set_s(::std::string&& value);
  #endif
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);

  // optional int64 i = 3;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 3;
  ::google::protobuf::int64 i() const;
  void set_i(::google::protobuf::int64 value);

  // optional float f = 2;
  bool has_f() const;
  void clear_f();
  static const int kFFieldNumber = 2;
  float f() const;
  void set_f(float value);

  // @@protoc_insertion_point(class_scope:tensorrt.Argument)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_f();
  void clear_has_f();
  void set_has_i();
  void clear_has_i();
  void set_has_s();
  void clear_has_s();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > floats_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > ints_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr s_;
  ::google::protobuf::int64 i_;
  float f_;
  friend struct ::protobuf_tensorrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OutputShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorrt.OutputShape) */ {
 public:
  OutputShape();
  virtual ~OutputShape();

  OutputShape(const OutputShape& from);

  inline OutputShape& operator=(const OutputShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutputShape(OutputShape&& from) noexcept
    : OutputShape() {
    *this = ::std::move(from);
  }

  inline OutputShape& operator=(OutputShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutputShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputShape* internal_default_instance() {
    return reinterpret_cast<const OutputShape*>(
               &_OutputShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(OutputShape* other);
  friend void swap(OutputShape& a, OutputShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutputShape* New() const final {
    return CreateMaybeMessage<OutputShape>(NULL);
  }

  OutputShape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OutputShape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OutputShape& from);
  void MergeFrom(const OutputShape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // @@protoc_insertion_point(class_scope:tensorrt.OutputShape)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  friend struct ::protobuf_tensorrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuantizeActivationInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorrt.QuantizeActivationInfo) */ {
 public:
  QuantizeActivationInfo();
  virtual ~QuantizeActivationInfo();

  QuantizeActivationInfo(const QuantizeActivationInfo& from);

  inline QuantizeActivationInfo& operator=(const QuantizeActivationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuantizeActivationInfo(QuantizeActivationInfo&& from) noexcept
    : QuantizeActivationInfo() {
    *this = ::std::move(from);
  }

  inline QuantizeActivationInfo& operator=(QuantizeActivationInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantizeActivationInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuantizeActivationInfo* internal_default_instance() {
    return reinterpret_cast<const QuantizeActivationInfo*>(
               &_QuantizeActivationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(QuantizeActivationInfo* other);
  friend void swap(QuantizeActivationInfo& a, QuantizeActivationInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuantizeActivationInfo* New() const final {
    return CreateMaybeMessage<QuantizeActivationInfo>(NULL);
  }

  QuantizeActivationInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QuantizeActivationInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const QuantizeActivationInfo& from);
  void MergeFrom(const QuantizeActivationInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuantizeActivationInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float scale = 1;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 1;
  float scale() const;
  void set_scale(float value);

  // optional int32 zero_point = 2;
  bool has_zero_point() const;
  void clear_zero_point();
  static const int kZeroPointFieldNumber = 2;
  ::google::protobuf::int32 zero_point() const;
  void set_zero_point(::google::protobuf::int32 value);

  // optional float minval = 3;
  bool has_minval() const;
  void clear_minval();
  static const int kMinvalFieldNumber = 3;
  float minval() const;
  void set_minval(float value);

  // optional float maxval = 4;
  bool has_maxval() const;
  void clear_maxval();
  static const int kMaxvalFieldNumber = 4;
  float maxval() const;
  void set_maxval(float value);

  // @@protoc_insertion_point(class_scope:tensorrt.QuantizeActivationInfo)
 private:
  void set_has_scale();
  void clear_has_scale();
  void set_has_zero_point();
  void clear_has_zero_point();
  void set_has_minval();
  void clear_has_minval();
  void set_has_maxval();
  void clear_has_maxval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float scale_;
  ::google::protobuf::int32 zero_point_;
  float minval_;
  float maxval_;
  friend struct ::protobuf_tensorrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperatorDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorrt.OperatorDef) */ {
 public:
  OperatorDef();
  virtual ~OperatorDef();

  OperatorDef(const OperatorDef& from);

  inline OperatorDef& operator=(const OperatorDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperatorDef(OperatorDef&& from) noexcept
    : OperatorDef() {
    *this = ::std::move(from);
  }

  inline OperatorDef& operator=(OperatorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatorDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatorDef* internal_default_instance() {
    return reinterpret_cast<const OperatorDef*>(
               &_OperatorDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OperatorDef* other);
  friend void swap(OperatorDef& a, OperatorDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperatorDef* New() const final {
    return CreateMaybeMessage<OperatorDef>(NULL);
  }

  OperatorDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperatorDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperatorDef& from);
  void MergeFrom(const OperatorDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatorDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 1;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  const ::std::string& input(int index) const;
  ::std::string* mutable_input(int index);
  void set_input(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_input(int index, ::std::string&& value);
  #endif
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  ::std::string* add_input();
  void add_input(const ::std::string& value);
  #if LANG_CXX11
  void add_input(::std::string&& value);
  #endif
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // repeated string output = 2;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 2;
  const ::std::string& output(int index) const;
  ::std::string* mutable_output(int index);
  void set_output(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_output(int index, ::std::string&& value);
  #endif
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  ::std::string* add_output();
  void add_output(const ::std::string& value);
  #if LANG_CXX11
  void add_output(::std::string&& value);
  #endif
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& output() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output();

  // repeated .tensorrt.Argument arg = 5;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 5;
  ::tensorrt::Argument* mutable_arg(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >*
      mutable_arg();
  const ::tensorrt::Argument& arg(int index) const;
  ::tensorrt::Argument* add_arg();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >&
      arg() const;

  // repeated .tensorrt.OutputShape output_shape = 6;
  int output_shape_size() const;
  void clear_output_shape();
  static const int kOutputShapeFieldNumber = 6;
  ::tensorrt::OutputShape* mutable_output_shape(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::OutputShape >*
      mutable_output_shape();
  const ::tensorrt::OutputShape& output_shape(int index) const;
  ::tensorrt::OutputShape* add_output_shape();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::OutputShape >&
      output_shape() const;

  // repeated .tensorrt.TensorType output_type = 7;
  int output_type_size() const;
  void clear_output_type();
  static const int kOutputTypeFieldNumber = 7;
  ::tensorrt::TensorType output_type(int index) const;
  void set_output_type(int index, ::tensorrt::TensorType value);
  void add_output_type(::tensorrt::TensorType value);
  const ::google::protobuf::RepeatedField<int>& output_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_output_type();

  // repeated .tensorrt.QuantizeActivationInfo quantize_info = 8;
  int quantize_info_size() const;
  void clear_quantize_info();
  static const int kQuantizeInfoFieldNumber = 8;
  ::tensorrt::QuantizeActivationInfo* mutable_quantize_info(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::QuantizeActivationInfo >*
      mutable_quantize_info();
  const ::tensorrt::QuantizeActivationInfo& quantize_info(int index) const;
  ::tensorrt::QuantizeActivationInfo* add_quantize_info();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::QuantizeActivationInfo >&
      quantize_info() const;

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:tensorrt.OperatorDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument > arg_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::OutputShape > output_shape_;
  ::google::protobuf::RepeatedField<int> output_type_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::QuantizeActivationInfo > quantize_info_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend struct ::protobuf_tensorrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InOutTensorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorrt.InOutTensorInfo) */ {
 public:
  InOutTensorInfo();
  virtual ~InOutTensorInfo();

  InOutTensorInfo(const InOutTensorInfo& from);

  inline InOutTensorInfo& operator=(const InOutTensorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InOutTensorInfo(InOutTensorInfo&& from) noexcept
    : InOutTensorInfo() {
    *this = ::std::move(from);
  }

  inline InOutTensorInfo& operator=(InOutTensorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InOutTensorInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InOutTensorInfo* internal_default_instance() {
    return reinterpret_cast<const InOutTensorInfo*>(
               &_InOutTensorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(InOutTensorInfo* other);
  friend void swap(InOutTensorInfo& a, InOutTensorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InOutTensorInfo* New() const final {
    return CreateMaybeMessage<InOutTensorInfo>(NULL);
  }

  InOutTensorInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InOutTensorInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InOutTensorInfo& from);
  void MergeFrom(const InOutTensorInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InOutTensorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float dims = 3;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 3;
  float dims(int index) const;
  void set_dims(int index, float value);
  void add_dims(float value);
  const ::google::protobuf::RepeatedField< float >&
      dims() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_dims();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:tensorrt.InOutTensorInfo)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > dims_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_tensorrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorrt.NetDef) */ {
 public:
  NetDef();
  virtual ~NetDef();

  NetDef(const NetDef& from);

  inline NetDef& operator=(const NetDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetDef(NetDef&& from) noexcept
    : NetDef() {
    *this = ::std::move(from);
  }

  inline NetDef& operator=(NetDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetDef* internal_default_instance() {
    return reinterpret_cast<const NetDef*>(
               &_NetDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NetDef* other);
  friend void swap(NetDef& a, NetDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetDef* New() const final {
    return CreateMaybeMessage<NetDef>(NULL);
  }

  NetDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NetDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NetDef& from);
  void MergeFrom(const NetDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorrt.OperatorDef op = 2;
  int op_size() const;
  void clear_op();
  static const int kOpFieldNumber = 2;
  ::tensorrt::OperatorDef* mutable_op(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::OperatorDef >*
      mutable_op();
  const ::tensorrt::OperatorDef& op(int index) const;
  ::tensorrt::OperatorDef* add_op();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::OperatorDef >&
      op() const;

  // repeated .tensorrt.Argument arg = 4;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 4;
  ::tensorrt::Argument* mutable_arg(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >*
      mutable_arg();
  const ::tensorrt::Argument& arg(int index) const;
  ::tensorrt::Argument* add_arg();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >&
      arg() const;

  // repeated .tensorrt.ConstTensor tensors = 5;
  int tensors_size() const;
  void clear_tensors();
  static const int kTensorsFieldNumber = 5;
  ::tensorrt::ConstTensor* mutable_tensors(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::ConstTensor >*
      mutable_tensors();
  const ::tensorrt::ConstTensor& tensors(int index) const;
  ::tensorrt::ConstTensor* add_tensors();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::ConstTensor >&
      tensors() const;

  // repeated .tensorrt.InOutTensorInfo input_info = 100;
  int input_info_size() const;
  void clear_input_info();
  static const int kInputInfoFieldNumber = 100;
  ::tensorrt::InOutTensorInfo* mutable_input_info(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >*
      mutable_input_info();
  const ::tensorrt::InOutTensorInfo& input_info(int index) const;
  ::tensorrt::InOutTensorInfo* add_input_info();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >&
      input_info() const;

  // repeated .tensorrt.InOutTensorInfo output_info = 101;
  int output_info_size() const;
  void clear_output_info();
  static const int kOutputInfoFieldNumber = 101;
  ::tensorrt::InOutTensorInfo* mutable_output_info(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >*
      mutable_output_info();
  const ::tensorrt::InOutTensorInfo& output_info(int index) const;
  ::tensorrt::InOutTensorInfo* add_output_info();
  const ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >&
      output_info() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:tensorrt.NetDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::OperatorDef > op_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument > arg_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::ConstTensor > tensors_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo > input_info_;
  ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo > output_info_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  friend struct ::protobuf_tensorrt_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConstTensor

// repeated int64 dims = 1;
inline int ConstTensor::dims_size() const {
  return dims_.size();
}
inline void ConstTensor::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 ConstTensor::dims(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.dims)
  return dims_.Get(index);
}
inline void ConstTensor::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.dims)
}
inline void ConstTensor::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.ConstTensor.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ConstTensor::dims() const {
  // @@protoc_insertion_point(field_list:tensorrt.ConstTensor.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ConstTensor::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.ConstTensor.dims)
  return &dims_;
}

// optional .tensorrt.TensorType data_type = 2 [default = DT_FLOAT];
inline bool ConstTensor::has_data_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConstTensor::set_has_data_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConstTensor::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConstTensor::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::tensorrt::TensorType ConstTensor::data_type() const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.data_type)
  return static_cast< ::tensorrt::TensorType >(data_type_);
}
inline void ConstTensor::set_data_type(::tensorrt::TensorType value) {
  assert(::tensorrt::TensorType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.data_type)
}

// repeated float float_data = 3 [packed = true];
inline int ConstTensor::float_data_size() const {
  return float_data_.size();
}
inline void ConstTensor::clear_float_data() {
  float_data_.Clear();
}
inline float ConstTensor::float_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.float_data)
  return float_data_.Get(index);
}
inline void ConstTensor::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.float_data)
}
inline void ConstTensor::add_float_data(float value) {
  float_data_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.ConstTensor.float_data)
}
inline const ::google::protobuf::RepeatedField< float >&
ConstTensor::float_data() const {
  // @@protoc_insertion_point(field_list:tensorrt.ConstTensor.float_data)
  return float_data_;
}
inline ::google::protobuf::RepeatedField< float >*
ConstTensor::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.ConstTensor.float_data)
  return &float_data_;
}

// repeated int32 int32_data = 4 [packed = true];
inline int ConstTensor::int32_data_size() const {
  return int32_data_.size();
}
inline void ConstTensor::clear_int32_data() {
  int32_data_.Clear();
}
inline ::google::protobuf::int32 ConstTensor::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.int32_data)
  return int32_data_.Get(index);
}
inline void ConstTensor::set_int32_data(int index, ::google::protobuf::int32 value) {
  int32_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.int32_data)
}
inline void ConstTensor::add_int32_data(::google::protobuf::int32 value) {
  int32_data_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.ConstTensor.int32_data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConstTensor::int32_data() const {
  // @@protoc_insertion_point(field_list:tensorrt.ConstTensor.int32_data)
  return int32_data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConstTensor::mutable_int32_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.ConstTensor.int32_data)
  return &int32_data_;
}

// optional string name = 5;
inline bool ConstTensor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConstTensor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConstTensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConstTensor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ConstTensor::name() const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.name)
  return name_.GetNoArena();
}
inline void ConstTensor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.name)
}
#if LANG_CXX11
inline void ConstTensor::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.ConstTensor.name)
}
#endif
inline void ConstTensor::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.ConstTensor.name)
}
inline void ConstTensor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.ConstTensor.name)
}
inline ::std::string* ConstTensor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tensorrt.ConstTensor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConstTensor::release_name() {
  // @@protoc_insertion_point(field_release:tensorrt.ConstTensor.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConstTensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.ConstTensor.name)
}

// optional int64 offset = 6;
inline bool ConstTensor::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConstTensor::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConstTensor::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConstTensor::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 ConstTensor::offset() const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.offset)
  return offset_;
}
inline void ConstTensor::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.offset)
}

// optional int64 data_size = 7;
inline bool ConstTensor::has_data_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConstTensor::set_has_data_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConstTensor::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConstTensor::clear_data_size() {
  data_size_ = GOOGLE_LONGLONG(0);
  clear_has_data_size();
}
inline ::google::protobuf::int64 ConstTensor::data_size() const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.data_size)
  return data_size_;
}
inline void ConstTensor::set_data_size(::google::protobuf::int64 value) {
  set_has_data_size();
  data_size_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.data_size)
}

// optional float scale = 8;
inline bool ConstTensor::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConstTensor::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConstTensor::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConstTensor::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float ConstTensor::scale() const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.scale)
  return scale_;
}
inline void ConstTensor::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.scale)
}

// optional int32 zero_point = 9;
inline bool ConstTensor::has_zero_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConstTensor::set_has_zero_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConstTensor::clear_has_zero_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConstTensor::clear_zero_point() {
  zero_point_ = 0;
  clear_has_zero_point();
}
inline ::google::protobuf::int32 ConstTensor::zero_point() const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.zero_point)
  return zero_point_;
}
inline void ConstTensor::set_zero_point(::google::protobuf::int32 value) {
  set_has_zero_point();
  zero_point_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.zero_point)
}

// optional bool quantized = 10 [default = false];
inline bool ConstTensor::has_quantized() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConstTensor::set_has_quantized() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConstTensor::clear_has_quantized() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConstTensor::clear_quantized() {
  quantized_ = false;
  clear_has_quantized();
}
inline bool ConstTensor::quantized() const {
  // @@protoc_insertion_point(field_get:tensorrt.ConstTensor.quantized)
  return quantized_;
}
inline void ConstTensor::set_quantized(bool value) {
  set_has_quantized();
  quantized_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.ConstTensor.quantized)
}

// -------------------------------------------------------------------

// Argument

// optional string name = 1;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:tensorrt.Argument.name)
  return name_.GetNoArena();
}
inline void Argument::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.Argument.name)
}
#if LANG_CXX11
inline void Argument::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.Argument.name)
}
#endif
inline void Argument::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.Argument.name)
}
inline ::std::string* Argument::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tensorrt.Argument.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:tensorrt.Argument.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.Argument.name)
}

// optional float f = 2;
inline bool Argument::has_f() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::set_has_f() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Argument::clear_has_f() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Argument::clear_f() {
  f_ = 0;
  clear_has_f();
}
inline float Argument::f() const {
  // @@protoc_insertion_point(field_get:tensorrt.Argument.f)
  return f_;
}
inline void Argument::set_f(float value) {
  set_has_f();
  f_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.Argument.f)
}

// optional int64 i = 3;
inline bool Argument::has_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::set_has_i() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Argument::clear_has_i() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Argument::clear_i() {
  i_ = GOOGLE_LONGLONG(0);
  clear_has_i();
}
inline ::google::protobuf::int64 Argument::i() const {
  // @@protoc_insertion_point(field_get:tensorrt.Argument.i)
  return i_;
}
inline void Argument::set_i(::google::protobuf::int64 value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.Argument.i)
}

// optional bytes s = 4;
inline bool Argument::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_s() {
  s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s();
}
inline const ::std::string& Argument::s() const {
  // @@protoc_insertion_point(field_get:tensorrt.Argument.s)
  return s_.GetNoArena();
}
inline void Argument::set_s(const ::std::string& value) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.Argument.s)
}
#if LANG_CXX11
inline void Argument::set_s(::std::string&& value) {
  set_has_s();
  s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.Argument.s)
}
#endif
inline void Argument::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.Argument.s)
}
inline void Argument::set_s(const void* value, size_t size) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.Argument.s)
}
inline ::std::string* Argument::mutable_s() {
  set_has_s();
  // @@protoc_insertion_point(field_mutable:tensorrt.Argument.s)
  return s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_s() {
  // @@protoc_insertion_point(field_release:tensorrt.Argument.s)
  if (!has_s()) {
    return NULL;
  }
  clear_has_s();
  return s_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    set_has_s();
  } else {
    clear_has_s();
  }
  s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.Argument.s)
}

// repeated float floats = 5;
inline int Argument::floats_size() const {
  return floats_.size();
}
inline void Argument::clear_floats() {
  floats_.Clear();
}
inline float Argument::floats(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.Argument.floats)
  return floats_.Get(index);
}
inline void Argument::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.Argument.floats)
}
inline void Argument::add_floats(float value) {
  floats_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.Argument.floats)
}
inline const ::google::protobuf::RepeatedField< float >&
Argument::floats() const {
  // @@protoc_insertion_point(field_list:tensorrt.Argument.floats)
  return floats_;
}
inline ::google::protobuf::RepeatedField< float >*
Argument::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.Argument.floats)
  return &floats_;
}

// repeated int64 ints = 6;
inline int Argument::ints_size() const {
  return ints_.size();
}
inline void Argument::clear_ints() {
  ints_.Clear();
}
inline ::google::protobuf::int64 Argument::ints(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.Argument.ints)
  return ints_.Get(index);
}
inline void Argument::set_ints(int index, ::google::protobuf::int64 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.Argument.ints)
}
inline void Argument::add_ints(::google::protobuf::int64 value) {
  ints_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.Argument.ints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Argument::ints() const {
  // @@protoc_insertion_point(field_list:tensorrt.Argument.ints)
  return ints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Argument::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.Argument.ints)
  return &ints_;
}

// -------------------------------------------------------------------

// OutputShape

// repeated int64 dims = 1;
inline int OutputShape::dims_size() const {
  return dims_.size();
}
inline void OutputShape::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 OutputShape::dims(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.OutputShape.dims)
  return dims_.Get(index);
}
inline void OutputShape::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.OutputShape.dims)
}
inline void OutputShape::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.OutputShape.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
OutputShape::dims() const {
  // @@protoc_insertion_point(field_list:tensorrt.OutputShape.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
OutputShape::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.OutputShape.dims)
  return &dims_;
}

// -------------------------------------------------------------------

// QuantizeActivationInfo

// optional float scale = 1;
inline bool QuantizeActivationInfo::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuantizeActivationInfo::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuantizeActivationInfo::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuantizeActivationInfo::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float QuantizeActivationInfo::scale() const {
  // @@protoc_insertion_point(field_get:tensorrt.QuantizeActivationInfo.scale)
  return scale_;
}
inline void QuantizeActivationInfo::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.QuantizeActivationInfo.scale)
}

// optional int32 zero_point = 2;
inline bool QuantizeActivationInfo::has_zero_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuantizeActivationInfo::set_has_zero_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuantizeActivationInfo::clear_has_zero_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuantizeActivationInfo::clear_zero_point() {
  zero_point_ = 0;
  clear_has_zero_point();
}
inline ::google::protobuf::int32 QuantizeActivationInfo::zero_point() const {
  // @@protoc_insertion_point(field_get:tensorrt.QuantizeActivationInfo.zero_point)
  return zero_point_;
}
inline void QuantizeActivationInfo::set_zero_point(::google::protobuf::int32 value) {
  set_has_zero_point();
  zero_point_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.QuantizeActivationInfo.zero_point)
}

// optional float minval = 3;
inline bool QuantizeActivationInfo::has_minval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuantizeActivationInfo::set_has_minval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuantizeActivationInfo::clear_has_minval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuantizeActivationInfo::clear_minval() {
  minval_ = 0;
  clear_has_minval();
}
inline float QuantizeActivationInfo::minval() const {
  // @@protoc_insertion_point(field_get:tensorrt.QuantizeActivationInfo.minval)
  return minval_;
}
inline void QuantizeActivationInfo::set_minval(float value) {
  set_has_minval();
  minval_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.QuantizeActivationInfo.minval)
}

// optional float maxval = 4;
inline bool QuantizeActivationInfo::has_maxval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuantizeActivationInfo::set_has_maxval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuantizeActivationInfo::clear_has_maxval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuantizeActivationInfo::clear_maxval() {
  maxval_ = 0;
  clear_has_maxval();
}
inline float QuantizeActivationInfo::maxval() const {
  // @@protoc_insertion_point(field_get:tensorrt.QuantizeActivationInfo.maxval)
  return maxval_;
}
inline void QuantizeActivationInfo::set_maxval(float value) {
  set_has_maxval();
  maxval_ = value;
  // @@protoc_insertion_point(field_set:tensorrt.QuantizeActivationInfo.maxval)
}

// -------------------------------------------------------------------

// OperatorDef

// repeated string input = 1;
inline int OperatorDef::input_size() const {
  return input_.size();
}
inline void OperatorDef::clear_input() {
  input_.Clear();
}
inline const ::std::string& OperatorDef::input(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.input)
  return input_.Get(index);
}
inline ::std::string* OperatorDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.OperatorDef.input)
  return input_.Mutable(index);
}
inline void OperatorDef::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorrt.OperatorDef.input)
  input_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperatorDef::set_input(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorrt.OperatorDef.input)
  input_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperatorDef::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorrt.OperatorDef.input)
}
inline void OperatorDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorrt.OperatorDef.input)
}
inline ::std::string* OperatorDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:tensorrt.OperatorDef.input)
  return input_.Add();
}
inline void OperatorDef::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.input)
}
#if LANG_CXX11
inline void OperatorDef::add_input(::std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.input)
}
#endif
inline void OperatorDef::add_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorrt.OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorrt.OperatorDef.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::input() const {
  // @@protoc_insertion_point(field_list:tensorrt.OperatorDef.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.OperatorDef.input)
  return &input_;
}

// repeated string output = 2;
inline int OperatorDef::output_size() const {
  return output_.size();
}
inline void OperatorDef::clear_output() {
  output_.Clear();
}
inline const ::std::string& OperatorDef::output(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.output)
  return output_.Get(index);
}
inline ::std::string* OperatorDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.OperatorDef.output)
  return output_.Mutable(index);
}
inline void OperatorDef::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorrt.OperatorDef.output)
  output_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperatorDef::set_output(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorrt.OperatorDef.output)
  output_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperatorDef::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorrt.OperatorDef.output)
}
inline void OperatorDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorrt.OperatorDef.output)
}
inline ::std::string* OperatorDef::add_output() {
  // @@protoc_insertion_point(field_add_mutable:tensorrt.OperatorDef.output)
  return output_.Add();
}
inline void OperatorDef::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.output)
}
#if LANG_CXX11
inline void OperatorDef::add_output(::std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.output)
}
#endif
inline void OperatorDef::add_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorrt.OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorrt.OperatorDef.output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::output() const {
  // @@protoc_insertion_point(field_list:tensorrt.OperatorDef.output)
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.OperatorDef.output)
  return &output_;
}

// optional string name = 3;
inline bool OperatorDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperatorDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperatorDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperatorDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OperatorDef::name() const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.name)
  return name_.GetNoArena();
}
inline void OperatorDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.OperatorDef.name)
}
#if LANG_CXX11
inline void OperatorDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.OperatorDef.name)
}
#endif
inline void OperatorDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.OperatorDef.name)
}
inline ::std::string* OperatorDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tensorrt.OperatorDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_name() {
  // @@protoc_insertion_point(field_release:tensorrt.OperatorDef.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.OperatorDef.name)
}

// optional string type = 4;
inline bool OperatorDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperatorDef::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperatorDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperatorDef::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& OperatorDef::type() const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.type)
  return type_.GetNoArena();
}
inline void OperatorDef::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.OperatorDef.type)
}
#if LANG_CXX11
inline void OperatorDef::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.OperatorDef.type)
}
#endif
inline void OperatorDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.OperatorDef.type)
}
inline ::std::string* OperatorDef::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:tensorrt.OperatorDef.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_type() {
  // @@protoc_insertion_point(field_release:tensorrt.OperatorDef.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.OperatorDef.type)
}

// repeated .tensorrt.Argument arg = 5;
inline int OperatorDef::arg_size() const {
  return arg_.size();
}
inline void OperatorDef::clear_arg() {
  arg_.Clear();
}
inline ::tensorrt::Argument* OperatorDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.OperatorDef.arg)
  return arg_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >*
OperatorDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.OperatorDef.arg)
  return &arg_;
}
inline const ::tensorrt::Argument& OperatorDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.arg)
  return arg_.Get(index);
}
inline ::tensorrt::Argument* OperatorDef::add_arg() {
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.arg)
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >&
OperatorDef::arg() const {
  // @@protoc_insertion_point(field_list:tensorrt.OperatorDef.arg)
  return arg_;
}

// repeated .tensorrt.OutputShape output_shape = 6;
inline int OperatorDef::output_shape_size() const {
  return output_shape_.size();
}
inline void OperatorDef::clear_output_shape() {
  output_shape_.Clear();
}
inline ::tensorrt::OutputShape* OperatorDef::mutable_output_shape(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.OperatorDef.output_shape)
  return output_shape_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::OutputShape >*
OperatorDef::mutable_output_shape() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.OperatorDef.output_shape)
  return &output_shape_;
}
inline const ::tensorrt::OutputShape& OperatorDef::output_shape(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.output_shape)
  return output_shape_.Get(index);
}
inline ::tensorrt::OutputShape* OperatorDef::add_output_shape() {
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.output_shape)
  return output_shape_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::OutputShape >&
OperatorDef::output_shape() const {
  // @@protoc_insertion_point(field_list:tensorrt.OperatorDef.output_shape)
  return output_shape_;
}

// repeated .tensorrt.TensorType output_type = 7;
inline int OperatorDef::output_type_size() const {
  return output_type_.size();
}
inline void OperatorDef::clear_output_type() {
  output_type_.Clear();
}
inline ::tensorrt::TensorType OperatorDef::output_type(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.output_type)
  return static_cast< ::tensorrt::TensorType >(output_type_.Get(index));
}
inline void OperatorDef::set_output_type(int index, ::tensorrt::TensorType value) {
  assert(::tensorrt::TensorType_IsValid(value));
  output_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.OperatorDef.output_type)
}
inline void OperatorDef::add_output_type(::tensorrt::TensorType value) {
  assert(::tensorrt::TensorType_IsValid(value));
  output_type_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.output_type)
}
inline const ::google::protobuf::RepeatedField<int>&
OperatorDef::output_type() const {
  // @@protoc_insertion_point(field_list:tensorrt.OperatorDef.output_type)
  return output_type_;
}
inline ::google::protobuf::RepeatedField<int>*
OperatorDef::mutable_output_type() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.OperatorDef.output_type)
  return &output_type_;
}

// repeated .tensorrt.QuantizeActivationInfo quantize_info = 8;
inline int OperatorDef::quantize_info_size() const {
  return quantize_info_.size();
}
inline void OperatorDef::clear_quantize_info() {
  quantize_info_.Clear();
}
inline ::tensorrt::QuantizeActivationInfo* OperatorDef::mutable_quantize_info(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.OperatorDef.quantize_info)
  return quantize_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::QuantizeActivationInfo >*
OperatorDef::mutable_quantize_info() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.OperatorDef.quantize_info)
  return &quantize_info_;
}
inline const ::tensorrt::QuantizeActivationInfo& OperatorDef::quantize_info(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.OperatorDef.quantize_info)
  return quantize_info_.Get(index);
}
inline ::tensorrt::QuantizeActivationInfo* OperatorDef::add_quantize_info() {
  // @@protoc_insertion_point(field_add:tensorrt.OperatorDef.quantize_info)
  return quantize_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::QuantizeActivationInfo >&
OperatorDef::quantize_info() const {
  // @@protoc_insertion_point(field_list:tensorrt.OperatorDef.quantize_info)
  return quantize_info_;
}

// -------------------------------------------------------------------

// InOutTensorInfo

// optional string name = 1;
inline bool InOutTensorInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InOutTensorInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InOutTensorInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InOutTensorInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& InOutTensorInfo::name() const {
  // @@protoc_insertion_point(field_get:tensorrt.InOutTensorInfo.name)
  return name_.GetNoArena();
}
inline void InOutTensorInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.InOutTensorInfo.name)
}
#if LANG_CXX11
inline void InOutTensorInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.InOutTensorInfo.name)
}
#endif
inline void InOutTensorInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.InOutTensorInfo.name)
}
inline void InOutTensorInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.InOutTensorInfo.name)
}
inline ::std::string* InOutTensorInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tensorrt.InOutTensorInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InOutTensorInfo::release_name() {
  // @@protoc_insertion_point(field_release:tensorrt.InOutTensorInfo.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InOutTensorInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.InOutTensorInfo.name)
}

// repeated float dims = 3;
inline int InOutTensorInfo::dims_size() const {
  return dims_.size();
}
inline void InOutTensorInfo::clear_dims() {
  dims_.Clear();
}
inline float InOutTensorInfo::dims(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.InOutTensorInfo.dims)
  return dims_.Get(index);
}
inline void InOutTensorInfo::set_dims(int index, float value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorrt.InOutTensorInfo.dims)
}
inline void InOutTensorInfo::add_dims(float value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:tensorrt.InOutTensorInfo.dims)
}
inline const ::google::protobuf::RepeatedField< float >&
InOutTensorInfo::dims() const {
  // @@protoc_insertion_point(field_list:tensorrt.InOutTensorInfo.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< float >*
InOutTensorInfo::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.InOutTensorInfo.dims)
  return &dims_;
}

// -------------------------------------------------------------------

// NetDef

// optional string name = 1;
inline bool NetDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& NetDef::name() const {
  // @@protoc_insertion_point(field_get:tensorrt.NetDef.name)
  return name_.GetNoArena();
}
inline void NetDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.NetDef.name)
}
#if LANG_CXX11
inline void NetDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.NetDef.name)
}
#endif
inline void NetDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.NetDef.name)
}
inline void NetDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.NetDef.name)
}
inline ::std::string* NetDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tensorrt.NetDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDef::release_name() {
  // @@protoc_insertion_point(field_release:tensorrt.NetDef.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.NetDef.name)
}

// repeated .tensorrt.OperatorDef op = 2;
inline int NetDef::op_size() const {
  return op_.size();
}
inline void NetDef::clear_op() {
  op_.Clear();
}
inline ::tensorrt::OperatorDef* NetDef::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.NetDef.op)
  return op_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::OperatorDef >*
NetDef::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.NetDef.op)
  return &op_;
}
inline const ::tensorrt::OperatorDef& NetDef::op(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.NetDef.op)
  return op_.Get(index);
}
inline ::tensorrt::OperatorDef* NetDef::add_op() {
  // @@protoc_insertion_point(field_add:tensorrt.NetDef.op)
  return op_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::OperatorDef >&
NetDef::op() const {
  // @@protoc_insertion_point(field_list:tensorrt.NetDef.op)
  return op_;
}

// optional string version = 3;
inline bool NetDef::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetDef::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetDef::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetDef::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& NetDef::version() const {
  // @@protoc_insertion_point(field_get:tensorrt.NetDef.version)
  return version_.GetNoArena();
}
inline void NetDef::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorrt.NetDef.version)
}
#if LANG_CXX11
inline void NetDef::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorrt.NetDef.version)
}
#endif
inline void NetDef::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorrt.NetDef.version)
}
inline void NetDef::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorrt.NetDef.version)
}
inline ::std::string* NetDef::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:tensorrt.NetDef.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDef::release_version() {
  // @@protoc_insertion_point(field_release:tensorrt.NetDef.version)
  if (!has_version()) {
    return NULL;
  }
  clear_has_version();
  return version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:tensorrt.NetDef.version)
}

// repeated .tensorrt.Argument arg = 4;
inline int NetDef::arg_size() const {
  return arg_.size();
}
inline void NetDef::clear_arg() {
  arg_.Clear();
}
inline ::tensorrt::Argument* NetDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.NetDef.arg)
  return arg_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >*
NetDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.NetDef.arg)
  return &arg_;
}
inline const ::tensorrt::Argument& NetDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.NetDef.arg)
  return arg_.Get(index);
}
inline ::tensorrt::Argument* NetDef::add_arg() {
  // @@protoc_insertion_point(field_add:tensorrt.NetDef.arg)
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::Argument >&
NetDef::arg() const {
  // @@protoc_insertion_point(field_list:tensorrt.NetDef.arg)
  return arg_;
}

// repeated .tensorrt.ConstTensor tensors = 5;
inline int NetDef::tensors_size() const {
  return tensors_.size();
}
inline void NetDef::clear_tensors() {
  tensors_.Clear();
}
inline ::tensorrt::ConstTensor* NetDef::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.NetDef.tensors)
  return tensors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::ConstTensor >*
NetDef::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.NetDef.tensors)
  return &tensors_;
}
inline const ::tensorrt::ConstTensor& NetDef::tensors(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.NetDef.tensors)
  return tensors_.Get(index);
}
inline ::tensorrt::ConstTensor* NetDef::add_tensors() {
  // @@protoc_insertion_point(field_add:tensorrt.NetDef.tensors)
  return tensors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::ConstTensor >&
NetDef::tensors() const {
  // @@protoc_insertion_point(field_list:tensorrt.NetDef.tensors)
  return tensors_;
}

// repeated .tensorrt.InOutTensorInfo input_info = 100;
inline int NetDef::input_info_size() const {
  return input_info_.size();
}
inline void NetDef::clear_input_info() {
  input_info_.Clear();
}
inline ::tensorrt::InOutTensorInfo* NetDef::mutable_input_info(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.NetDef.input_info)
  return input_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >*
NetDef::mutable_input_info() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.NetDef.input_info)
  return &input_info_;
}
inline const ::tensorrt::InOutTensorInfo& NetDef::input_info(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.NetDef.input_info)
  return input_info_.Get(index);
}
inline ::tensorrt::InOutTensorInfo* NetDef::add_input_info() {
  // @@protoc_insertion_point(field_add:tensorrt.NetDef.input_info)
  return input_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >&
NetDef::input_info() const {
  // @@protoc_insertion_point(field_list:tensorrt.NetDef.input_info)
  return input_info_;
}

// repeated .tensorrt.InOutTensorInfo output_info = 101;
inline int NetDef::output_info_size() const {
  return output_info_.size();
}
inline void NetDef::clear_output_info() {
  output_info_.Clear();
}
inline ::tensorrt::InOutTensorInfo* NetDef::mutable_output_info(int index) {
  // @@protoc_insertion_point(field_mutable:tensorrt.NetDef.output_info)
  return output_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >*
NetDef::mutable_output_info() {
  // @@protoc_insertion_point(field_mutable_list:tensorrt.NetDef.output_info)
  return &output_info_;
}
inline const ::tensorrt::InOutTensorInfo& NetDef::output_info(int index) const {
  // @@protoc_insertion_point(field_get:tensorrt.NetDef.output_info)
  return output_info_.Get(index);
}
inline ::tensorrt::InOutTensorInfo* NetDef::add_output_info() {
  // @@protoc_insertion_point(field_add:tensorrt.NetDef.output_info)
  return output_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorrt::InOutTensorInfo >&
NetDef::output_info() const {
  // @@protoc_insertion_point(field_list:tensorrt.NetDef.output_info)
  return output_info_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorrt

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tensorrt::TensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorrt::TensorType>() {
  return ::tensorrt::TensorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorrt_2eproto
